#! /usr/bin/env node

const readline = require('readline');
const fs = require('fs');

const lineType = {
	id: 'id',
	time: 'time',
	text: 'text',
}

const timeDelimiter = '-->';

function printHelp() {
	console.log(`
usage: srt-shift [-i <path>] [-o <path>]

-i, --input	input file
-o, --output	output file
-s, --shift	shift all subtitles in milliseconds, e.g. +1233 would add 1233 milliseconds
		to all subtitles, and -645 would subtract 645 milliseconds from each subtitle
	`);
}

function validateInput(input) {
	if (!input.inputFile || !input.outputFile) {
		throw 'Incorrect arguments';
	}
	if (!fs.existsSync(input.inputFile)) {
		throw 'Input file does not exist';
	};
	if (fs.existsSync(input.outputFile)) {
		throw 'Output file already exists';
	};
	let shiftMs = 0;
	if (input.shiftBy) {
		const s = input.shiftBy.trim();
		if (s.startsWith('+') || s.startsWith('-')) {
			shiftMs = Number(input.shiftBy)
			if (isNaN(shiftMs)) {
				throw 'Incorrect shift';
			}
		} else {
			throw 'Incorrect shift';
		}
	}
	return {
		inputFile: input.inputFile,
		outputFile: input.outputFile,
		shiftMs,
	}
}

function getInput(argv) {
	let args = argv.slice(2)
	args = args.map(a => a.trim());
	let i = 0;
	let inputFile, outputFile, shiftBy;
	while(i < args.length) {
		const arg = args[i];
		switch(arg.trim()) {
			case '-i': 
			case '--input':
				if (inputFile) {
					throw 'Incorrect arguments'
				}
				inputFile = args[i + 1];
				break;
			case '-o':
			case '--output':
				if (outputFile) {
					throw 'Incorrect arguments'
				}
				outputFile = args[i + 1];
				break;
			case '-s':
			case '--shift':
				if (shiftBy) {
					throw 'Incorrect arguments'
				}
				shiftBy = args[i + 1];
				break;
			default:

		}
		i++;
	}

	return {
		inputFile,
		outputFile,
		shiftBy,
		shiftMs:0,
	}
}


function readInputFile(fileName, callback) {
	const map = {};
	const rl = readline.createInterface({
		input: fs.createReadStream(fileName),
		output: process.stdout,
		terminal: false
	});
	let currentLineType = lineType.id;
	let currentId = null;
	rl.on('line', (line) => {
		if (lineType.id === currentLineType) {
			currentId = line.trim();
			map[currentId] = {};
			currentLineType = lineType.time;
		} else if (lineType.time === currentLineType) {
			const [startTime, endTime] = line.split(timeDelimiter).map(l => l.trim());
			map[currentId].startTimeMs = toMilli(startTime); 
			map[currentId].endTimeMs = toMilli(endTime); 
			currentLineType = lineType.text;
		} else if (lineType.text === currentLineType) {
			if (line.trim() === '') {
				currentLineType = lineType.id;
			} else {
				const text = line;
				if (map[currentId].lines === undefined) {
					map[currentId].lines = [text];
				} else {
					map[currentId].lines.push(text);
				};
			}
		}
	});
	rl.on('close', () => {
		callback(map);
	});
}

function writeOutputFile(filePath, map) {
	const fileLines = [];
	Object.keys(map).map(Number).sort((a,b) => a - b).forEach(id => {
		fileLines.push(id);
		fileLines.push(
			`${toTimestamp(map[id].startTimeMs)} ${timeDelimiter} ${toTimestamp(map[id].endTimeMs)}`
		);
		fileLines.push(...map[id].lines);
		fileLines.push('');
	});
	fs.writeFile(filePath, fileLines.join('\n'), error => {
		if (error) {
			console.log(error);
		} else {
			console.log('File Saved.');
		}
	});
}

function toMilli(time) {
	//'00:02:35,728'
	const [hrmmss, ms] = time.split(',');
	const [hr, mm, ss] = hrmmss.split(':');
	return Number(ms) + Number(ss) * 1_000 + Number(mm) * 60 * 1_000 + Number(hr) * 60 * 60 * 1_000;
}

function toTimestamp(millis) {
	//142415
	const hr = Math.floor(millis / (60 * 60 * 1_000));
	const mm = Math.floor((millis - (hr * 60 * 60 * 1_000)) / (60 *  1_000));
	const ss = Math.floor((millis - (hr * 60 * 60 * 1_000) - (mm * 60 * 1_000)) / 1_000);
	const ms = millis - (hr * 60 * 60 * 1_000) - (mm * 60 * 1_000) - (ss * 1_000);
	return `${prependZeros(hr, 2)}:${prependZeros(mm, 2)}:${prependZeros(ss, 2)},${prependZeros(ms, 3)}`;
}

function prependZeros(num, p) {
	let numStr = String(num);
	if (numStr.length > p) {
		throw 'bad format';
	} 
	while(numStr.length < p) {
		numStr = `0${numStr}`;
	}
	return numStr;
}

try {
	const input = getInput(process.argv);
	const validatedInput = validateInput(input);
	readInputFile(validatedInput.inputFile, map => {
		const shiftedMap = {};
		for (const [key, value] of Object.entries(map)) {
			shiftedMap[key] = {
				...value,
				startTimeMs: value.startTimeMs + validatedInput.shiftMs,
				endTimeMs: value.endTimeMs + validatedInput.shiftMs,
			}
		}
		console.log(map);
		console.log(shiftedMap);
		writeOutputFile(validatedInput.outputFile, shiftedMap);
	});
} catch (e) {
	console.log(e);
	printHelp();
}
